# Configuration script for sphinx trainer

$CFG_VERBOSE = 1;		# Determines how much goes to the screen.

# These are filled in at configuration time
$CFG_DB_NAME = '___DB_NAME___';
$CFG_BASE_DIR = '___BASE_DIR___';
$CFG_SPHINXTRAIN_DIR = '___SPHINXTRAIN_DIR___';

$CFG_BIN_DIR = "$CFG_BASE_DIR/bin";
$CFG_GIF_DIR = "$CFG_BASE_DIR/gifs";
$CFG_SCRIPT_DIR = "$CFG_BASE_DIR/scripts_pl";

$CFG_EXPTNAME = "perl_"."$CFG_DB_NAME";
$CFG_JOBNAME  = "perl_"."$CFG_DB_NAME"."_job";
$CFG_FEATFILES_DIR = "$CFG_BASE_DIR/feat";
$CFG_FEATFILE_EXTENSION = 'feat';
$CFG_VECTOR_LENGTH = 13;
$CFG_MIN_ITERATIONS = 7;  # BW Iterate at least this many times
$CFG_MAX_ITERATIONS = 30; # BW Don't iterate more than this, somethings likely wrong.
$CFG_AGC = 'none';
$CFG_CMN = 'current';
$CFG_VARNORM = 'no';
$CFG_GENDER = 'g';
$CFG_USE_LSF = 0;
$CFG_LSF_MACHINES = 'processc processf processg processh processi processj processk processl processm processn processo processp';

$CFG_SCRIPT_DIR = "$CFG_BASE_DIR/scripts_pl";
$CFG_QMGR_DIR = "$CFG_BASE_DIR/qmanager";
$CFG_LOG_DIR = "$CFG_BASE_DIR/logdir";
$CFG_BWACCUM_DIR = "$CFG_BASE_DIR/bwaccumdir";
$CFG_MODEL_DIR = "$CFG_BASE_DIR/model_parameters";

#*******variables used in main training of 3st. models*******
$CFG_DICTIONARY     = "$CFG_BASE_DIR/etc/"."$CFG_DB_NAME".".dic";
$CFG_RAWPHONEFILE   = "$CFG_BASE_DIR/etc/"."$CFG_DB_NAME".".phone";
$CFG_FILLERDICT     = "$CFG_BASE_DIR/etc/"."$CFG_DB_NAME".".filler";
$CFG_LISTOFFILES    = "$CFG_BASE_DIR/etc/"."$CFG_DB_NAME".".fileids";
$CFG_TRANSCRIPTFILE = "$CFG_BASE_DIR/etc/"."$CFG_DB_NAME".".transcription";

#*******variables used in main training of 3st. models*******

$CFG_STATESPERHMM = 5;
$CFG_SKIPSTATE = 'yes';

# Single stream features - sphinxIII
#set feature = 1s_12c_12d_3p_12dd # 
#set num_streams = 1

# Four (4) stream features for fbs8
$CFG_FEATURE = "c/1..L-1/,d/1..L-1/,c/0/d/0/dd/0/,dd/1..L-1/";
$CFG_NUM_STREAMS = 4;


$CFG_N_TIED_STATES = 6000;
$CFG_NITER = 10;

$CFG_NPART = 1;			#  Define how many pieces to run baum welch in
$CFG_NPART_UNTIED = 1;		

#$CFG_TYPE = '.cont.'; # Sphinx III
$CFG_HMM_TYPE  = '.semi.'; # Sphinx II
$CFG_FORCEDALIGN = 'no';

#set convergence_ratio = 0.004
$CFG_CONVERGENCE_RATIO = 0.004;

$CFG_QPRIORITY = "priority";	# Not supported on this release

$CFG_QUESTION_SET = "${CFG_BASE_DIR}/model_architecture/${CFG_EXPTNAME}.tree_questions";
#$CFG_QUESTION_SET = "${CFG_BASE_DIR}/linguistic_questions";


# Specific configs for each module

#VQ
$CFG_VQ_LOG_DIR = "$CFG_LOG_DIR/01.vector_quantize";
$CFG_VQ_PERL_DIR = "$CFG_BASE_DIR/scripts_pl/01.vector_quantize";

#CI
$CFG_CI_PERL_DIR = "$CFG_BASE_DIR/scripts_pl/02.ci_schmm";
$CFG_CI_LOG_DIR = "$CFG_LOG_DIR/02.ci_schmm";
$CFG_CI_TOPN = 4;

$CFG_OKAY_COLOR = '00D000';
$CFG_WARNING_COLOR = '555500';
$CFG_ERROR_COLOR = 'DD0000';

sub ST_DateStr()
{
    my (@time) = localtime(time());
    my ($day_str) = sprintf ("%4d-%02d-%02d %02d:%02d",(1900 + $time[5]), ($time[4]+1),$time[3],$time[2],$time[1]);
}


sub ST_Log ()
{
    my $message = shift;
    my (@time) = localtime(time());
    my ($day_str) = sprintf ("%4d-%02d-%02d %02d:%02d",(1900 + $time[5]), ($time[4]+1),$time[3],$time[2],$time[1]);
    my $logfile = "$CFG_BASE_DIR/$CFG_EXPTNAME.html";

    print "$message" if $CFG_VERBOSE;
    if (-s $logfile) {
	open ST_HTML_LOG,">>$logfile";
	if ($message =~ m/^(MODULE:).*/) {
	    print ST_HTML_LOG "<hr>\n";
	    chomp ($message);
	    print ST_HTML_LOG "<b>$message\t($day_str)</b>\n";	# Put Date information on Module headers
	} else {
	    print ST_HTML_LOG "$message";
	}
	close ST_HTML_LOG;
    } else {
	open ST_HTML_LOG,">$logfile";
	print ST_HTML_LOG "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\n";
	print ST_HTML_LOG "<html>\n";
	print ST_HTML_LOG "<head>\n";
	print ST_HTML_LOG "<META HTTP-EQUIV=REFRESH CONTENT=60>\n"; # Force reloading every 60 seconds
	print ST_HTML_LOG "<title>$CFG_EXPTNAME</title>\n";
	print ST_HTML_LOG "</head>\n";
	print ST_HTML_LOG "<body BGCOLOR = \"#F0F0F5\">\n";
	print ST_HTML_LOG "<pre>\n";
	print ST_HTML_LOG "<CENTER><h1>${CFG_BASE_DIR}/${CFG_EXPTNAME}</h1></CENTER>\n";
	print ST_HTML_LOG "<CENTER> <h3>$hostname</h3></CENTER>\n";
	print ST_HTML_LOG "<hr>\n";
	if ($message =~ m/^(MODULE:).*/) {
	    chomp ($message);
	    print ST_HTML_LOG "<b>$message\t($day_str)</b>\n";	# Put Date information on Module headers
	} else {
	    print ST_HTML_LOG "$message";
	}
	close ST_HTML_LOG;
    }
}

sub ST_HTML_Print () 
{
    my $message = shift;
    my $logfile = "$CFG_BASE_DIR/$CFG_EXPTNAME.html";

    if (-s $logfile) {
	open ST_HTML_LOG,">>$logfile";
	print ST_HTML_LOG $message;
	close ST_HTML_LOG;
    } else {
	open ST_HTML_LOG,">$logfile";
	print ST_HTML_LOG "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\n";
	print ST_HTML_LOG "<html>\n";
	print ST_HTML_LOG "<head>\n";
	print ST_HTML_LOG "<META HTTP-EQUIV=REFRESH CONTENT=60>\n"; # Force reloading every 60 seconds
	print ST_HTML_LOG "<title>$CFG_EXPTNAME</title>\n";
	print ST_HTML_LOG "</head>\n";
	print ST_HTML_LOG "<body BGCOLOR = \"#F0F0F5\">\n";
	print ST_HTML_LOG "<pre>\n";
	print ST_HTML_LOG "<CENTER><h1>${CFG_BASE_DIR}/${CFG_EXPTNAME}</h1></CENTER>\n";
	print ST_HTML_LOG "<CENTER> <h3>$hostname</h3></CENTER>\n";
	print ST_HTML_LOG "<hr>\n";
	print ST_HTML_LOG "$message";
	close ST_HTML_LOG;
    }

}

sub ST_LogWarning ()
{
    my $message = shift;
    my (@time) = localtime(time());
    my ($day_str) = sprintf ("%4d-%02d-%02d %02d:%02d",(1900 + $time[5]), ($time[4]+1),$time[3],$time[2],$time[1]);
    my $logfile = "$CFG_BASE_DIR/$CFG_EXPTNAME.html";

    print "WARNING: $message" if $CFG_VERBOSE;
    if (-s $logfile) {
	open ST_HTML_LOG,">>$logfile";
	print ST_HTML_LOG "WARNING: $message";
	close ST_HTML_LOG;
    } else {
	open ST_HTML_LOG,">$logfile";
	print ST_HTML_LOG "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\n";
	print ST_HTML_LOG "<html>\n";
	print ST_HTML_LOG "<head>\n";
	print ST_HTML_LOG "<META HTTP-EQUIV=REFRESH CONTENT=60>\n"; # Force reloading every 60 seconds
	print ST_HTML_LOG "<title>$CFG_EXPTNAME</title>\n";
	print ST_HTML_LOG "</head>\n";
	print ST_HTML_LOG "<body BGCOLOR = \"#F0F0F5\">\n";
	print ST_HTML_LOG "<pre>\n";
	print ST_HTML_LOG "<CENTER><h1>${CFG_BASE_DIR}/${CFG_EXPTNAME}</h1></CENTER>\n";
	print ST_HTML_LOG "<CENTER> <h3>$hostname</h3></CENTER>\n";
	print ST_HTML_LOG "<hr>\n";
	print ST_HTML_LOG "WARNING: $message";
	close ST_HTML_LOG;
    }
}

sub ST_LogError ()
{
    my $message = shift;
    my (@time) = localtime(time());
    my ($day_str) = sprintf ("%4d-%02d-%02d %02d:%02d",(1900 + $time[5]), ($time[4]+1),$time[3],$time[2],$time[1]);
    my $logfile = "$CFG_BASE_DIR/$CFG_EXPTNAME.html";

    chomp ($message);		# remove \n if it exists

    print "ERROR: $message" if $CFG_VERBOSE;
    if (-s $logfile) {
	open ST_HTML_LOG,">>$logfile";
	print ST_HTML_LOG "ERROR: $message";
	close ST_HTML_LOG;
    } else {
	open ST_HTML_LOG,">$logfile";
	print ST_HTML_LOG "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\n";
	print ST_HTML_LOG "<html>\n";
	print ST_HTML_LOG "<head>\n";
	print ST_HTML_LOG "<META HTTP-EQUIV=REFRESH CONTENT=60>\n"; # Force reloading every 60 seconds
	print ST_HTML_LOG "<title>$CFG_EXPTNAME</title>\n";
	print ST_HTML_LOG "</head>\n";
	print ST_HTML_LOG "<body BGCOLOR = \"#F0F0F5\">\n";
	print ST_HTML_LOG "<pre>\n";
	print ST_HTML_LOG "<CENTER><h1>${CFG_BASE_DIR}/${CFG_EXPTNAME}</h1></CENTER>\n";
	print ST_HTML_LOG "<CENTER> <h3>$hostname</h3></CENTER>\n";
	print ST_HTML_LOG "<hr>\n";
	print ST_HTML_LOG "ERROR: $message";
	close ST_HTML_LOG;
    }
}

sub ST_Converged ()
{
  my $iter = shift;
  my $logdir = shift;
  my ($l,$p,$ratio);

  # See what happened at this iteration
  $l = `grep \"overall>\" $logdir/${CFG_EXPTNAME}.${iter}-*.bw.log | awk '{X += \$3;Y += \$6} END {print Y/X}'`;

  if ($iter > 1) {
      my $tmp_iter = $iter - 1;
      # See what happened last iteration
      $p = `grep \"overall>\" $logdir/${CFG_EXPTNAME}.${tmp_iter}-*.bw.log | awk '{X += \$3;Y += \$6} END {print Y/X}'`;
      # Compute it's ratio
      $ratio = ($l-$p)/abs($p);
      &ST_Log ("\t\tRatio: $ratio\n");
  }

  # Don't even bother checking convergence until we've reached a minimum number of loops
  return 0 if ($iter < $CFG_MIN_ITERATIONS);
  return 1 if ($ratio < $CFG_CONVERGENCE_RATIO);
  return 2 if ($iter > $CFG_MAX_ITERATIONS);
}





return 1;
